#!/bin/bash
#####
# Creates symlinks in the home directory pointing to all files in the given 
# dotfiles directory. It will symlink files in sub directories as well.
#
# It does not create symlinks for files in the following special directories:
# .hg, .git, bin, $backupDir, source, apps.list
#
# Bin directory: added to the path via the bashrc file
# source directory: all files in source directory are executed via a command in bashrc
# Backup Directory: before creating the symlinks to the dot files. We check if the file already exists in the ~ 
# directory or sub directory. If it does exist then the file is copied to the backup directory with a timestamp 
# appended to the filename. The files in the backup directory maintain the directory structure.
# minimal list
# apps.list: Stores a line delimited list of application which the user might want to install
# 
# more than one repo. I am currently using a dotfiles and dotfiles_private. With the command line arguments I can use 
# dotm for both cases. I setup my default paths for my dotfiles in dotm. Then for my private files I setup and alias
# for dotmp which passes the private dot file directory and different repository.
#
# Can be added to a cron job to automatically pull changes and symlink files. :-)
#
# Git is only required if a remote repository will be used to store/pull dot file changes.
#
# Inspired by:
# https://github.com/cowboy/dotfiles
# http://vcs-home.branchable.com/
# http://blog.smalleycreative.com/tutorials/using-git-and-github-to-manage-your-dotfiles/
#
######

#NOTE: 
# 1. checkout files
# 2. Ask user: link everything? or link minimal? or link one by one?
# 3. Check if ~/bin is in the path and if not add it
#
#simple command to pull this script from github and run it.
# wget -O - https://raw.github.com/brettbatie/dotfiles/master/bin/dotm | bash

##########################################
# SETTINGS

# Set the dot directory and check for arguments
dotDir=$HOME/dotfiles
backupDir=$HOME/dotfiles/backup
masterRepository=git://github.com/brettbatie/dotfiles

# comma delimited list for only creating a minimal set of symlinks
minimalSymlinkFiles=".vimrc,.gitconfig"



#
#########################################

function help {
cat << EOF
USAGE: $(basename $0) [-options] [-d /path/to/dotFileDirectory] [-r masterRepository]

    -d dotFileDirectory : The directory that contains the static files that will
                         be linked to from the ~ directory. If the 
                         dotFileDirectory is not specified then ~/dotfiles is
                         used by default.

    -r masterRepository : The url/path to the git repository that changes will 
                         be pushed and pulled from.

    -a : Will create symlinks for all files in the dot file directory without 
         asking questions. Special directories (bin, source, etc) will still be
         skipped.

    -m : Create symlinks using the minimal list

    -h : this help screen
EOF



}

function checkParameters {
    if [ "$1" ==  "--help" ]; then
        help
        exit 0
    fi

    local OPTIND=1 # Reset in case getopts has been used previously in the shell.

    while getopts ":d:r:amh" opt; do
      case $opt in
        d)
            dotDir=$OPTARG;
            ;;
        r)
            masterRepository=$OPTARG;
            ;;
        a)
            symlinkOption="all"
            ;;
        m)
            symlinkOption="minimal"
            ;;
        h|\?)
            help
            exit 0
            ;;
      esac
    done

    # Verify that the dot directory exists
    if [ ! -d "$dotDir" ]; then
        echo "The dotfile directory ($dotDir) does not exist. Creating it"
        mkdir -v -p $dotDir;
    fi

    # Trim the trailing slash from the dot directory (if there is one)
    if [[ $dotDir == */ ]]; then
        $dotDir=${dotDir%?}
    fi
}

function updateRepo {
    # Check if git is installed before doing git operations
    type git >/dev/null 2>&1 || { echo >&2 "Git is required to clone/pull dot files from a remote repository. "\
        "Symlinks can still be auto created to files in $dotDir but a remote repository will not be used."; break;}

    # if there is repo here update it, otherwise create the repo
    if [ ! -d "$dotDir/.git" ]; then
        displayTitle "DOWNLOADING MASTER REPOSITORY ($masterRepository)"
        git clone $masterRepository $dotDir
    else
        displayTitle "Updating Master Repository"
        (cd $dotDir && git pull $masterRepository)
    fi
}



function symlinkOption {
    # no need to ask questions if the user specified the setting with a startup 
    # parameter
    if [ -n "$symlinkOption" ]; then
        return;
    fi

    # Check for files before asking questions
    # FIXME: this find should be using the same find arguments as in the function createSymLink. Should create that as a
    #        variable earlier in the code. This will detect the basic case of empty directories.
    fileCount=$(find $dotDir -type f -not -path "$dotDir/.git/*" | wc -l);
    if [ "$fileCount" == "0" ]; then
        echo "There are zero files in the $dotDir to create symlinks for. Add some files to this directory and then "\
             "run it again."
        exit 0;
    fi

    PS3="Select how to create create the symlinks?"
    options=("Create all symlinks                         " #hack to get the columns on new lines. Is there a better way?
    "Ask before creating each"
     "Use minimal list ($minimalSymlinkFiles)"
     )
    select opt in "${options[@]}"
    do
        case $opt in
            "Create all symlinks                         ")
                symlinkOption="all"
                break;
                ;;
            "Ask before creating each")
                symlinkOption="ask"
                break;
                ;;
            "Use minimal list ($minimalSymlinkFiles)")
                symlinkOption="minimal"
                break;
                ;;
            *) echo invalid option;;
        esac
    done
}

function displayTitle {
    echo -e "\e[4m\033[1m$1\033[0m"
}

function createSymLinks {

    local symlinksCreated=0;

    # Determine if we are going to use a minimal list of files to symlink
    if [ "$symlinkOption" == "minimal" ]; then
        if [ "$minimalSymlinkFiles" == "" ]; then
            echo "No minimal files to symlink, exiting."
            exit 1;
        fi
        minimalSymlinkFiles="-name ${minimalSymlinkFiles/,/ -name }"
    else
        minimalSymlinkFiles=""
    fi

    displayTitle "Creating Symlinks in ~ for all files in $dotDir"

    # create the symlinks for every file in the given dotfile directory.
    for file in $(find "$dotDir" -type f $minimalSymlinkFiles \
        -not -path "$dotDir/.hg/*" \
        -not -path "$dotDir/.git/*" \
        -not -path "$backupDir" \
        -not -path "$dotDir/apps.list" \
        -not -path "$dotDir/bin/*" \
        -not -path "$dotDir/source/*"); do
        
        # get the file with a path relative to the dotDir
        local relativeFile=${file#$dotDir} #remove $dotDir from $file

        # Remove the leading slash if there is one
        if [[ $relativeFile == /* ]]; then
            relativeFile=${relativeFile:1}
        fi

        # If the symlink is already in place, move to the next file, nothing to do
        local destinationFile="$(readlink -f $HOME/$relativeFile)"
        if [ "$destinationFile" == "$file" ]; then
            continue;
        fi


        if [ "$symlinkOption" == "ask" ]; then
            read -p "Create symlink ~/$relativeFile -> $file? [y/n] " -n 1 -r
            echo 
            # if not yes, then skip it
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                continue
            fi
        fi

        # Create a backup if there is a file that will be overwritten
        if [ -f "$HOME/$relativeFile" ]; then
            # create the backup directory, if necessary
            if [ ! -d "$backupDir" ]; then
                echo "Creating $backupDir for backup of any existing dotfiles in ~"
                mkdir -p "$backupDir"
            fi

            echo "Making backup of $relativeFile in $backupDir"
            mv -v $HOME/$relativeFile $backupDir/$relativeFile.$(date +"%Y%m%d%H%M")
        fi

        # Strip the filename from the relative Path
        local destionationDir=$(dirname ${relativeFile})

        # Make sure that the destination directory exists
        if [ -d $destinationDir ]; then
            mkdir -p $destionationDir
        fi

        echo "Creating symlink ~/$relativeFile -> $file"
        ln -s "$file" "$HOME/$relativeFile"

        # If this is a bashrc file it will need to be sourced
        if [ "$relativeFile" == ".bashrc" ]; then
            # wish I could automate this for the parent shell.
            echo 'To update your current shell run the command, source ~/.bashrc';
        fi

        symlinksCreated=$(($symlinksCreated+1))
    done;
    echo "Created $symlinksCreated new symlinks in ~"
}

checkParameters $@
updateRepo
symlinkOption
createSymLinks